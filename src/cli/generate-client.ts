import { writeFileSync, mkdirSync } from 'node:fs';
import { join } from 'node:path';
import { introspectServer } from './introspector';
import { TypeGenerator } from './type-generator';
import {
    MCPToolDefinition,
    GenerateClientOptions,
    ServerIntrospection,
} from '../interfaces';

/**
 * Generate a type-safe TypeScript client from a running MCP server
 */
export async function generateClient(
    options: GenerateClientOptions,
): Promise<void> {
    const { serverUrl, outputDir, clientName } = options;

    // Introspect the server
    const introspection = await introspectServer(serverUrl);

    // Create output directories
    mkdirSync(outputDir, { recursive: true });
    mkdirSync(join(outputDir, 'tools'), { recursive: true });
    mkdirSync(join(outputDir, 'resources'), { recursive: true });
    mkdirSync(join(outputDir, 'prompts'), { recursive: true });
    mkdirSync(join(outputDir, 'types'), { recursive: true });

    // Generate files
    generateTypes(introspection, outputDir);
    generateTools(introspection, outputDir);
    generateResources(introspection, outputDir);
    generatePrompts(introspection, outputDir);
    generateClientRuntime(outputDir);
    generateIndex(introspection, outputDir, clientName);
    generatePackageJson(clientName, outputDir);

    /* eslint-disable no-undef */
    console.log(`\nðŸ“¦ Generated client structure:`);
    console.log(`   ${introspection.tools.length} tools`);
    console.log(`   ${introspection.resources.length} resources`);
    console.log(`   ${introspection.prompts.length} prompts`);
    /* eslint-enable no-undef */
}

/**
 * Generate TypeScript type definitions
 */
function generateTypes(
    introspection: ServerIntrospection,
    outputDir: string,
): void {
    const types: string[] = [
        '// Auto-generated type definitions',
        '// Do not edit this file manually\n',
    ];

    // Generate types for each tool
    introspection.tools.forEach((tool) => {
        const typeName = TypeGenerator.toTypeName(tool.name) + 'Params';
        const schema = parametersToSchema(tool.parameters);
        types.push(TypeGenerator.generateInterface(typeName, schema));
        types.push('');
    });

    // Generate types for each prompt
    introspection.prompts.forEach((prompt) => {
        if (prompt.arguments && prompt.arguments.length > 0) {
            const typeName = TypeGenerator.toTypeName(prompt.name) + 'Args';
            const schema = promptArgsToSchema(prompt.arguments);
            types.push(TypeGenerator.generateInterface(typeName, schema));
            types.push('');
        }
    });

    writeFileSync(join(outputDir, 'types', 'index.ts'), types.join('\n'));
}

/**
 * Generate tool wrapper functions
 */
function generateTools(
    introspection: ServerIntrospection,
    outputDir: string,
): void {
    const toolsCode: string[] = [
        "import { MCPClient } from '../client';",
        "import * as Types from '../types';\n",
        '/**',
        ' * Type-safe tool wrappers',
        ' */',
        'export class Tools {',
        '  constructor(private client: MCPClient) {}\n',
    ];

    introspection.tools.forEach((tool) => {
        const typeName = TypeGenerator.toTypeName(tool.name) + 'Params';
        const hasParams = tool.parameters && tool.parameters.length > 0;
        const paramsType = hasParams ? `params: Types.${typeName}` : '';
        const callParams = hasParams ? 'params' : '{}';

        toolsCode.push(`  /**`);
        toolsCode.push(`   * ${tool.description}`);
        if (tool.version) {
            toolsCode.push(`   * @version ${tool.version}`);
        }
        if (tool.deprecated) {
            toolsCode.push(
                `   * @deprecated ${tool.deprecationMessage || 'This tool is deprecated'}`,
            );
        }
        toolsCode.push(`   */`);
        toolsCode.push(
            `  async ['${tool.name}'](${paramsType}): Promise<any> {`,
        );
        toolsCode.push(
            `    return this.client.callTool('${tool.name}', ${callParams});`,
        );
        toolsCode.push(`  }\n`);
    });

    toolsCode.push('}');

    writeFileSync(join(outputDir, 'tools', 'index.ts'), toolsCode.join('\n'));
}

/**
 * Generate resource wrapper functions
 */
function generateResources(
    introspection: ServerIntrospection,
    outputDir: string,
): void {
    const resourcesCode: string[] = [
        "import { MCPClient } from '../client';\n",
        '/**',
        ' * Type-safe resource wrappers',
        ' */',
        'export class Resources {',
        '  constructor(private client: MCPClient) {}\n',
        '  /**',
        '   * Read any resource by URI',
        '   */',
        '  async read(uri: string): Promise<any> {',
        '    return this.client.readResource(uri);',
        '  }\n',
    ];

    // Add named methods for static resources
    introspection.resources
        .filter((r) => r.uri && !r.uriTemplate)
        .forEach((resource) => {
            const methodName = resource.name
                .replace(/[^a-zA-Z0-9]+/g, '_')
                .toLowerCase();
            resourcesCode.push(`  /**`);
            resourcesCode.push(`   * ${resource.description || resource.name}`);
            resourcesCode.push(`   * URI: ${resource.uri}`);
            resourcesCode.push(`   */`);
            resourcesCode.push(`  async ${methodName}(): Promise<any> {`);
            resourcesCode.push(
                `    return this.client.readResource('${resource.uri}');`,
            );
            resourcesCode.push(`  }\n`);
        });

    resourcesCode.push('}');

    writeFileSync(
        join(outputDir, 'resources', 'index.ts'),
        resourcesCode.join('\n'),
    );
}

/**
 * Generate prompt wrapper functions
 */
function generatePrompts(
    introspection: ServerIntrospection,
    outputDir: string,
): void {
    const promptsCode: string[] = [
        "import { MCPClient } from '../client';",
        "import * as Types from '../types';\n",
        '/**',
        ' * Type-safe prompt wrappers',
        ' */',
        'export class Prompts {',
        '  constructor(private client: MCPClient) {}\n',
    ];

    introspection.prompts.forEach((prompt) => {
        const hasArgs = prompt.arguments && prompt.arguments.length > 0;
        const typeName = TypeGenerator.toTypeName(prompt.name) + 'Args';
        const argsType = hasArgs ? `args: Types.${typeName}` : '';
        const callArgs = hasArgs ? 'args' : '{}';

        promptsCode.push(`  /**`);
        promptsCode.push(`   * ${prompt.description || prompt.name}`);
        promptsCode.push(`   */`);
        promptsCode.push(
            `  async ['${prompt.name}'](${argsType}): Promise<any> {`,
        );
        promptsCode.push(
            `    return this.client.getPrompt('${prompt.name}', ${callArgs});`,
        );
        promptsCode.push(`  }\n`);
    });

    promptsCode.push('}');

    writeFileSync(
        join(outputDir, 'prompts', 'index.ts'),
        promptsCode.join('\n'),
    );
}

/**
 * Generate client runtime
 */
function generateClientRuntime(outputDir: string): void {
    const clientCode = `/**
 * Base MCP Client for making JSON-RPC calls to an MCP server
 */
export class MCPClient {
    private idCounter = 1;

    constructor(private readonly baseUrl: string) {}

    /**
     * Make a JSON-RPC call to the MCP server
     */
    async call(method: string, params?: unknown): Promise<unknown> {
        const response = await fetch(this.baseUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                jsonrpc: '2.0',
                id: this.idCounter++,
                method,
                params,
            }),
        });

        if (!response.ok) {
            throw new Error(\`HTTP \${response.status}: \${response.statusText}\`);
        }

        const data = await response.json();

        if (data.error) {
            throw new Error(
                \`MCP Error [\${data.error.code}]: \${data.error.message}\`,
            );
        }

        return data.result;
    }

    /**
     * Call a tool
     */
    async callTool(
        name: string,
        args: Record<string, unknown>,
    ): Promise<unknown> {
        return this.call('tools/call', { name, arguments: args });
    }

    /**
     * Read a resource
     */
    async readResource(uri: string): Promise<unknown> {
        return this.call('resources/read', { uri });
    }

    /**
     * Get a prompt
     */
    async getPrompt(
        name: string,
        args: Record<string, unknown>,
    ): Promise<unknown> {
        return this.call('prompts/get', { name, arguments: args });
    }
}
`;

    writeFileSync(join(outputDir, 'client.ts'), clientCode);
}

/**
 * Generate main index file
 */
function generateIndex(
    introspection: ServerIntrospection,
    outputDir: string,
    clientName: string,
): void {
    const indexCode = `/**
 * ${clientName}
 * Auto-generated MCP client
 * Server: ${introspection.serverInfo.name} v${introspection.serverInfo.version}
 */

import { MCPClient } from './client';
import { Tools } from './tools';
import { Resources } from './resources';
import { Prompts } from './prompts';
export * from './types';

/**
 * Create a new MCP client instance
 */
export function createClient(serverUrl: string) {
    const client = new MCPClient(serverUrl);
    
    return {
        tools: new Tools(client),
        resources: new Resources(client),
        prompts: new Prompts(client),
        _client: client,
    };
}

/**
 * Default export for convenience
 */
export const mcp = {
    create: createClient,
};
`;

    writeFileSync(join(outputDir, 'index.ts'), indexCode);
}

/**
 * Generate package.json for the client
 */
function generatePackageJson(clientName: string, outputDir: string): void {
    const packageJson = {
        name: clientName,
        version: '1.0.0',
        description: 'Auto-generated MCP client',
        main: 'index.ts',
        types: 'index.ts',
        private: true,
    };

    writeFileSync(
        join(outputDir, 'package.json'),
        JSON.stringify(packageJson, null, 2),
    );
}

/**
 * Convert MCP parameters to JSON Schema
 */
function parametersToSchema(parameters: MCPToolDefinition['parameters']): {
    type: string;
    properties: Record<
        string,
        { type: string; description?: string; enum?: unknown[] }
    >;
    required: string[];
} {
    const properties: Record<
        string,
        { type: string; description?: string; enum?: unknown[] }
    > = {};
    const required: string[] = [];

    parameters.forEach((param) => {
        properties[param.name] = {
            type: param.type,
            description: param.description,
            enum: param.enum as unknown[],
        };
        if (param.required) {
            required.push(param.name);
        }
    });

    return {
        type: 'object',
        properties,
        required,
    };
}

/**
 * Convert prompt arguments to JSON Schema
 */
function promptArgsToSchema(
    args: Array<{ name: string; description?: string; required?: boolean }>,
): {
    type: string;
    properties: Record<string, { type: string; description?: string }>;
    required: string[];
} {
    const properties: Record<string, { type: string; description?: string }> =
        {};
    const required: string[] = [];

    args.forEach((arg) => {
        properties[arg.name] = {
            type: 'string',
            description: arg.description,
        };
        if (arg.required) {
            required.push(arg.name);
        }
    });

    return {
        type: 'object',
        properties,
        required,
    };
}
